// Generated by dts-bundle-generator v8.0.1

export type CLIResponse = {
	props: Props;
	command: Command;
};
/**
 * Given initial props and a CLI, parses the arguments and options and returns the command and props.
 */
export declare function cli(initialProps: InitialProps): Promise<CLIResponse>;
/**
 * This is the main entry point to your CLI and takes the initial run options,
 * parses the proper command, positional arguments, and options, and then
 * calls the command with all arguments and options defined.
 */
export declare function run(initialProps: InitialProps): Promise<void>;
export type CommandTree = {
	[key: string]: Command & {
		subcommands?: CommandTree;
	};
};
/**
 * Builds a tree of commands from the ./commands folder.
 *
 * Subcommands are loaded recursively and added to the `subcommands` property of each parent command.
 *
 * The default command is at key "default" in the root level.
 */
export declare function commandTree(initialProps: InitialProps, subfolder?: string[]): Promise<CommandTree>;
export declare function commandHelp(initialProps: InitialProps): Promise<string>;
export type PrintFunction = {
	(...opts: any[]): void;
	setMocked: (mocked: boolean) => void;
	mocked?: boolean;
	testOutput?: string;
};
export declare const print: PrintFunction;
export declare const write: (text: string) => boolean;
export declare const specialKeys: {
	readonly "\u001B[A": "up";
	readonly "\u001B[B": "down";
	readonly "\u001B[C": "right";
	readonly "\u001B[D": "left";
	readonly "\u0003": "ctrl-c";
	readonly "": "backspace";
	readonly "\u001B": "escape";
	readonly "\u0004": "ctrl-d";
	readonly "\u0005": "ctrl-e";
	readonly "\u0006": "ctrl-f";
	readonly "\u0007": "ctrl-g";
	readonly "\b": "ctrl-h";
	readonly "\v": "ctrl-k";
	readonly "\f": "ctrl-l";
	readonly "\r": "enter";
	readonly "\t": "tab";
	readonly "\n": "enter";
	readonly "\u001B[1~": "home";
	readonly "\u001B[2~": "insert";
	readonly "\u001B[3~": "delete";
	readonly "\u001B[4~": "end";
	readonly "\u001B[5~": "pageup";
	readonly "\u001B[6~": "pagedown";
	readonly "\u001B[7~": "home";
	readonly "\u001B[8~": "end";
	readonly "\u001B[1;5A": "ctrl-up";
	readonly "\u001B[1;5B": "ctrl-down";
	readonly "\u001B[1;5C": "ctrl-right";
	readonly "\u001B[1;5D": "ctrl-left";
	readonly "\u001B[1;2A": "shift-up";
	readonly "\u001B[1;2B": "shift-down";
	readonly "\u001B[1;2C": "shift-right";
	readonly "\u001B[1;2D": "shift-left";
	readonly "\u001B[1;3A": "alt-up";
	readonly "\u001B[1;3B": "alt-down";
	readonly "\u001B[1;3C": "alt-right";
	readonly "\u001B[1;3D": "alt-left";
	readonly "\u001B[1;4A": "alt-shift-up";
	readonly "\u001B[1;4B": "alt-shift-down";
	readonly "\u001B[1;4C": "alt-shift-right";
	readonly "\u001B[1;4D": "alt-shift-left";
};
export declare const ESC: "\u001B[";
export declare const styleStart: <Sty extends number>(style: Sty) => `\u001B[${Sty}`;
export declare const styleEnd: <Res extends number>(reset: Res) => `\u001B[${Res}`;
export declare const style: <Sty extends number, Res extends number>(style: Sty, reset: Res) => <Txt extends string>(text: Txt) => `\u001B[${Sty}${Txt}\u001B[${Res}`;
export declare const bold: <Txt extends string>(text: Txt) => `\u001B[1${Txt}\u001B[22`;
export declare const italic: <Txt extends string>(text: Txt) => `\u001B[3${Txt}\u001B[23`;
export declare const underline: <Txt extends string>(text: Txt) => `\u001B[4${Txt}\u001B[24`;
export declare const inverse: <Txt extends string>(text: Txt) => `\u001B[7${Txt}\u001B[27`;
export declare const strikethrough: <Txt extends string>(text: Txt) => `\u001B[9${Txt}\u001B[29`;
export declare const colorStart: <Col extends number>(color: Col) => `\u001B[${Col}m`;
export declare const colorEnd: "\u001B[39m";
export declare const bgColorEnd: "\u001B[49m";
export declare const color: <Col extends number>(col: Col) => <Txt extends string>(text: Txt) => `\u001B[${Col}m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[${Col}m${Rest}` : Txt}\u001B[39m`;
export declare const bgColor: <Col extends number>(col: Col) => <Txt extends string>(text: Txt) => `\u001B[${Col}m${Txt extends `${infer First}\u001B[49m${infer Rest}` ? `${First}\u001B[${Col}m${Rest}` : Txt}\u001B[49m`;
export declare const hexToRgb: <Hex extends string>(hex: Hex) => readonly [
	number,
	number,
	number
];
export declare const colorHex: <Hex extends string>(hex: Hex) => <Txt extends string>(text: Txt) => `\u001B[38;2;${number};${number};${number}m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[38;2;${number};${number};${number}m${Rest}` : Txt}\u001B[39m`;
export declare const colorHexStart: <Hex extends string>(hex: Hex) => `\u001B[38;2;${number};${number};${number}m`;
export declare const bgColorHex: <Hex extends string>(hex: Hex) => <Txt extends string>(text: Txt) => `\u001B[48;2;${number};${number};${number}m${Txt extends `${infer First}\u001B[49m${infer Rest}` ? `${First}\u001B[48;2;${number};${number};${number}m${Rest}` : Txt}\u001B[49m`;
export declare const bgColorHexStart: <Hex extends string>(hex: Hex) => `\u001B[48;2;${number};${number};${number}m`;
export declare const colorRGBStart: <R extends number, G extends number, B extends number>(r: R, g: G, b: B) => `\u001B[38;2;${R};${G};${B}m`;
export declare const colorRGB: <R extends number, G extends number, B extends number>(r: R, g: G, b: B) => <Txt extends string>(text: Txt) => `\u001B[38;2;${R};${G};${B}m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[38;2;${R};${G};${B}m${Rest}` : Txt}\u001B[39m`;
export declare const bgColorRGBStart: <R extends number, G extends number, B extends number>(r: R, g: G, b: B) => `\u001B[48;2;${R};${G};${B}m`;
export declare const bgColorRGB: <R extends number, G extends number, B extends number>(r: R, g: G, b: B) => <Txt extends string>(text: Txt) => `\u001B[48;2;${R};${G};${B}m${Txt extends `${infer First}\u001B[49m${infer Rest}` ? `${First}\u001B[48;2;${R};${G};${B}m${Rest}` : Txt}\u001B[49m`;
export declare const ansiColors: {
	readonly white: 37;
	readonly black: 30;
	readonly blue: 34;
	readonly cyan: 36;
	readonly green: 32;
	readonly magenta: 35;
	readonly red: 31;
	readonly yellow: 33;
	readonly grey: 90;
	readonly gray: 90;
	readonly brightBlack: 90;
	readonly brightRed: 91;
	readonly brightGreen: 92;
	readonly brightYellow: 93;
	readonly brightBlue: 94;
	readonly brightMagenta: 95;
	readonly brightCyan: 96;
	readonly brightWhite: 97;
	readonly bgWhite: 47;
	readonly bgBlack: 40;
	readonly bgBlue: 44;
	readonly bgCyan: 46;
	readonly bgGreen: 42;
	readonly bgMagenta: 45;
	readonly bgRed: 41;
	readonly bgYellow: 43;
	readonly bgGrey: 100;
	readonly bgGray: 100;
	readonly bgBrightBlack: 100;
	readonly bgBrightRed: 101;
	readonly bgBrightGreen: 102;
	readonly bgBrightYellow: 103;
	readonly bgBrightBlue: 104;
	readonly bgBrightMagenta: 105;
	readonly bgBrightCyan: 106;
	readonly bgBrightWhite: 107;
};
export declare const white: <Txt extends string>(text: Txt) => `\u001B[37m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[37m${Rest}` : Txt}\u001B[39m`;
export declare const black: <Txt extends string>(text: Txt) => `\u001B[30m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[30m${Rest}` : Txt}\u001B[39m`;
export declare const blue: <Txt extends string>(text: Txt) => `\u001B[34m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[34m${Rest}` : Txt}\u001B[39m`;
export declare const cyan: <Txt extends string>(text: Txt) => `\u001B[36m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[36m${Rest}` : Txt}\u001B[39m`;
export declare const green: <Txt extends string>(text: Txt) => `\u001B[32m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[32m${Rest}` : Txt}\u001B[39m`;
export declare const magenta: <Txt extends string>(text: Txt) => `\u001B[35m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[35m${Rest}` : Txt}\u001B[39m`;
export declare const red: <Txt extends string>(text: Txt) => `\u001B[31m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[31m${Rest}` : Txt}\u001B[39m`;
export declare const yellow: <Txt extends string>(text: Txt) => `\u001B[33m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[33m${Rest}` : Txt}\u001B[39m`;
export declare const grey: <Txt extends string>(text: Txt) => `\u001B[90m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[90m${Rest}` : Txt}\u001B[39m`;
export declare const gray: <Txt extends string>(text: Txt) => `\u001B[90m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[90m${Rest}` : Txt}\u001B[39m`;
export declare const brightBlack: <Txt extends string>(text: Txt) => `\u001B[90m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[90m${Rest}` : Txt}\u001B[39m`;
export declare const brightRed: <Txt extends string>(text: Txt) => `\u001B[91m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[91m${Rest}` : Txt}\u001B[39m`;
export declare const brightGreen: <Txt extends string>(text: Txt) => `\u001B[92m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[92m${Rest}` : Txt}\u001B[39m`;
export declare const brightYellow: <Txt extends string>(text: Txt) => `\u001B[93m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[93m${Rest}` : Txt}\u001B[39m`;
export declare const brightBlue: <Txt extends string>(text: Txt) => `\u001B[94m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[94m${Rest}` : Txt}\u001B[39m`;
export declare const brightMagenta: <Txt extends string>(text: Txt) => `\u001B[95m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[95m${Rest}` : Txt}\u001B[39m`;
export declare const brightCyan: <Txt extends string>(text: Txt) => `\u001B[96m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[96m${Rest}` : Txt}\u001B[39m`;
export declare const brightWhite: <Txt extends string>(text: Txt) => `\u001B[97m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[97m${Rest}` : Txt}\u001B[39m`;
export declare const bgWhite: <Txt extends string>(text: Txt) => `\u001B[47m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[47m${Rest}` : Txt}\u001B[39m`;
export declare const bgBlack: <Txt extends string>(text: Txt) => `\u001B[40m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[40m${Rest}` : Txt}\u001B[39m`;
export declare const bgBlue: <Txt extends string>(text: Txt) => `\u001B[44m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[44m${Rest}` : Txt}\u001B[39m`;
export declare const bgCyan: <Txt extends string>(text: Txt) => `\u001B[46m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[46m${Rest}` : Txt}\u001B[39m`;
export declare const bgGreen: <Txt extends string>(text: Txt) => `\u001B[42m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[42m${Rest}` : Txt}\u001B[39m`;
export declare const bgMagenta: <Txt extends string>(text: Txt) => `\u001B[45m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[45m${Rest}` : Txt}\u001B[39m`;
export declare const bgRed: <Txt extends string>(text: Txt) => `\u001B[41m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[41m${Rest}` : Txt}\u001B[39m`;
export declare const bgYellow: <Txt extends string>(text: Txt) => `\u001B[43m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[43m${Rest}` : Txt}\u001B[39m`;
export declare const bgGrey: <Txt extends string>(text: Txt) => `\u001B[100m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[100m${Rest}` : Txt}\u001B[39m`;
export declare const bgGray: <Txt extends string>(text: Txt) => `\u001B[100m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[100m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightBlack: <Txt extends string>(text: Txt) => `\u001B[100m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[100m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightRed: <Txt extends string>(text: Txt) => `\u001B[101m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[101m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightGreen: <Txt extends string>(text: Txt) => `\u001B[102m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[102m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightYellow: <Txt extends string>(text: Txt) => `\u001B[103m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[103m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightBlue: <Txt extends string>(text: Txt) => `\u001B[104m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[104m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightMagenta: <Txt extends string>(text: Txt) => `\u001B[105m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[105m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightCyan: <Txt extends string>(text: Txt) => `\u001B[106m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[106m${Rest}` : Txt}\u001B[39m`;
export declare const bgBrightWhite: <Txt extends string>(text: Txt) => `\u001B[107m${Txt extends `${infer First}\u001B[39m${infer Rest}` ? `${First}\u001B[107m${Rest}` : Txt}\u001B[39m`;
export type AskOptions = {
	validation?: (answer: string) => true | string;
	after?: "preserve" | "clear";
	inputColor?: keyof typeof ansiColors;
};
export type AskFunction = {
	(prompt?: string, askOptions?: AskOptions): Promise<string>;
	mock?: (prompt: string) => Promise<string> | string;
};
export declare const ask: AskFunction;
export type ChooseOptions = {
	style: "horizontal" | "vertical";
	after?: "show-choice" | "preserve" | "clear";
};
export declare function choose(selections: string[], options?: ChooseOptions): Promise<string | undefined>;
export type InputKeyFunction = {
	(): Promise<string>;
	mock?: () => Promise<string> | string;
};
export declare const inputKey: InputKeyFunction;
export type PromiseOrValue<T> = T | Promise<T>;
export type InputKeysFunction = <T>(callback: (k: string) => PromiseOrValue<T | undefined>) => Promise<T>;
export declare const inputKeys: InputKeysFunction;
/**
 * ANSI escape sequences.
 */
export declare const cursorCodes: {
	readonly up: "A";
	readonly down: "B";
	readonly forward: "C";
	readonly back: "D";
	readonly nextLine: "E";
	readonly previousLine: "F";
	readonly horizontalAbsolute: "G";
	readonly home: "H";
	readonly eraseData: "J";
	readonly eraseAfter: "0K";
	readonly eraseBefore: "1K";
	readonly eraseLine: "2K";
	readonly eraseCharacter: "X";
	readonly clearScreen: "2J";
	readonly scrollUp: "S";
	readonly scrollDown: "T";
	readonly enterAlternativeScreen: "?1049h";
	readonly exitAlternativeScreen: "?1049l";
	readonly savePosition: string;
	readonly restorePosition: string;
	readonly goToPosition: (cols: number, rows: number) => string;
	readonly hide: "?25l";
	readonly show: "?25h";
};
/**
 * Moving the cursor around the terminal. Needs testing on Windows.
 */
export declare class Cursor {
	bookmarks: {
		[key: string]: CursorPos;
	};
	c(s: string, esc?: string): this;
	write(s: string): this;
	up(count?: number): this;
	down(count?: number): this;
	forward(count?: number): this;
	back(count?: number): this;
	moveDown(count?: number): this;
	moveUp(count?: number): this;
	backToStart(): this;
	backToHome(): this;
	horizontalAbsolute(count?: number): this;
	eraseBefore(count?: number): this;
	eraseLine(): this;
	erase(count?: number): this;
	clearScreen(): this;
	scrollUp(count?: number): this;
	scrollDown(count?: number): this;
	goto(pos: CursorPos): this;
	savePosition(): this;
	restorePosition(): this;
	hide(): this;
	show(): this;
	backspace(count?: number): this;
	alternate(enabled: boolean): this;
	jump(name: string): this;
	queryPosition(): Promise<CursorPos>;
	bookmark(name: string, pos?: CursorPos): Promise<CursorPos>;
}
export declare const cursor: Cursor;
export declare function queryPosition(): Promise<CursorPos>;
/**
 * Start a spinner. Returns a Timer object that can be used to stop the spinner.
 */
export declare function spinStart(text: string): Timer;
/**
 * Stop any currently spinning spinner. If no mark is provided, then a checkmark (âœ“) is used.
 */
export declare function spinStop(mark?: string, text?: string): void;
export declare function progressStart({ length, startValue, bar, empty, fps }: {
	length?: number | undefined;
	startValue?: number | undefined;
	bar?: string | undefined;
	empty?: string | undefined;
	fps?: number | undefined;
}): void;
export declare function progressUpdate(value: number): void;
export declare function progressEnd(action?: "fulfill" | "preserve" | "clear"): void;
/**
 * Returns largest string in an array. Useful for aligning text.
 */
export declare function largest(arr: string[]): string;
/**
 * Recursively crawls a command tree and returns the longest command name.
 * Useful for aligning text in a help message.
 */
export declare function calcWidestCommandName(cmdTree: CommandTree, start?: number): number;
/**
 * Strips ansi codes from a string.
 * Useful for testing.
 */
export declare function stripANSI(str: string): string;
/**
 * Async delay x milliseconds.
 */
export declare function delay(ms: number): Promise<unknown>;
/**
 * Super smart string replace
 */
export type Replace<T extends string, S extends string, R extends string> = T extends `${infer First}${S}${infer Rest}` ? `${First}${R}${Rest}` : T;
export declare function replace<T extends string, S extends string, R extends string>(target: T, searchValue: S, replaceValue: R): Replace<T, S, R>;
export type Updater = (k: string, newValue: string) => void;
/**
 * This prints a billboard with continually updating information (text).
 *
 * Provide it with a string and it'll respond back with an updater function
 * that lets you update any of the elements.
 *
 * You can designate an element with a 1-letter code wrapped in curly braces,
 * like `{a}` or `{b}`.
 *
 * Minimum length of reactive text is 3 characters.
 *
 * pos is a `{ rows: number, cols: number }` object that tells the billboard
 * where to start printing. It can be offset from the left side of the screen.
 */
export declare function billboard(text: string, pos: CursorPos): Updater;
export interface CursorPos {
	rows: number;
	cols: number;
}
export type InitialProps = {
	/**
	 * This is the name of the CLI. It's used to find the default command.
	 * It's is required.
	 */
	name: string;
	/**
	 * This is the path to the directory where the ./commands folder is.
	 * It is required, because we have no other way to infer it.
	 *
	 * It's usually `__dirname + "/cli"`
	 */
	cliPath: string;
	/**
	 * Usually process.argv, but can be changed for testing.
	 */
	argv?: string[];
};
export type Props = {
	name: string;
	cliPath: string;
	argv: string[];
	commandPath?: string[];
	arguments?: string[];
	options: {
		[key: string]: string | boolean;
	};
	first?: string;
	second?: string;
	third?: string;
};
export type Command = {
	name: string;
	description: string;
	run: (props: Props) => Promise<void>;
	alias?: string | string[];
};

export {};
